name: jarversion-cli-build-$(Date:yyyyMMdd)$(Rev:.r)

# trigger:
# - main

parameters:
- name: version
  type: string
  default: 'latest'

variables:
  buildDir: 'build/package'

jobs:
- job: BuildJarVersionTool
  displayName: 'Build jarversion CLI tool'
  pool:
    vmImage: 'ubuntu-latest'

  steps:
  - checkout: self

  - script: |
      echo "Injecting version number ${{ parameters.version }} into jarversion.go"
      sed -i "s/^const toolVersion = .*/const toolVersion = \"${{ parameters.version }}\"/" ./cmd/jarversion/main.go
    displayName: 'Inject version into source code'

  - script: |
      go install github.com/jstemmer/go-junit-report/v2@latest
      go install github.com/axw/gocov/gocov@latest
      go install github.com/AlekSi/gocov-xml@latest
      go install github.com/matm/gocov-html/cmd/gocov-html@latest
      export PATH="$(go env GOPATH)/bin:$PATH"
      go test -v -coverprofile=coverage.txt -covermode count ./cmd/jarversion 2>&1 | go-junit-report > report.xml
      gocov convert coverage.txt > coverage.json
      gocov-xml < coverage.json > coverage.xml
      mkdir coverage
      gocov-html < coverage.json > coverage/index.html
    workingDirectory: '$(system.defaultWorkingDirectory)'
    displayName: 'Run unit test'
    
  - task: PublishTestResults@2
    inputs:
      testRunner: JUnit
      testResultsFiles: $(System.DefaultWorkingDirectory)/**/report.xml

  - task: PublishCodeCoverageResults@2
    inputs:      
      summaryFileLocation: $(System.DefaultWorkingDirectory)/**/coverage.xml    

  - script: |
      chmod +x ./build_all.sh
      ./build_all.sh "${{ parameters.version }}"
    displayName: 'Run build_all.sh with version'
  
  - script: |
      buildDate=$(date +%Y%m%d)
      buildRev=1  # You can increment this manually or use a counter mechanism
      releaseName="jarversion-cli-build-${{ parameters.version }}"
      echo "##vso[task.setvariable variable=releaseName]$releaseName"
    displayName: 'Generate release name'

  - task: CopyFiles@2
    displayName: 'Stage files for publishing'
    inputs:
      Sourcefolder: '$(buildDir)'
      contents: |
        **/*
        !**/.keep
      TargetFolder: '$(buildDir)/filtered'

  - task: PublishBuildArtifacts@1
    inputs:
      pathtoPublish: '$(buildDir)/filtered'      
      artifactName: '$(releaseName)'
      publishLocation: 'Container'
    displayName: 'Publish build artifacts'

  - ${{ if ne(parameters.version, 'latest') }}:    
    - task: UniversalPackages@0
      displayName: 'Publish to Universal Feed'
      inputs:
        command: publish
        publishDirectory: '$(buildDir)/filtered'      # Folder containing your artifact
        vstsFeedPublish: 'IngOne/jarversion-cli'      # Format: <ProjectName>/<FeedName>
        vstsFeedPackagePublish: 'jarversion-cli'      # Package name (lowercase, no spaces)
        versionOption: custom
        versionPublish: '${{ parameters.version }}'   # Use semantic versioning
        packagePublishDescription: 'CLI tool for JAR version extraction'

  # - script: |
  #     git config user.email "build@azuredevops"
  #     git config user.name "Azure DevOps Pipeline"
  #     git tag $(releaseName)
  #     git remote set-url origin https://$(System.AccessToken)@dev.azure.com/your-org/your-project/_git/your-repo
  #     git push origin $(releaseName)
  #   displayName: 'Tag Release with Generated Name'
  #   env:
  #     System.AccessToken: $(System.AccessToken)
 

  # - task: AzureDevOpsNotifier@1
  #   inputs:
  #     message: 'Pipeline completed for version ${{ parameters.version }}'
  #   condition: always()
  #   displayName: 'Send pipeline notification'
